//! Data structures for the organized dictionary data.

use std::collections::HashMap;
use std::fs;
use std::io;

use std::io::BufWriter;
use std::io::Write;

use crate::dict::{Dict, Kanji, Tag, Term};

/// Root structure for dictionary data.
#[derive(Default)]
pub struct DB {
	strings: Vec<String>,
	indexes: HashMap<String, usize>,
	freq_terms: HashMap<String, u32>,
	freq_kanji: HashMap<String, u32>,

	tag_map: HashMap<usize, usize>,
	tags: Vec<TagRow>,

	terms: Vec<TermRow>,
	kanji: Vec<KanjiRow>,
}

impl DB {
	/// Imports dictionary data into the dictionary.
	pub fn import_dict(&mut self, dict: Dict) {
		for it in dict.tags {
			self.import_tag(it);
		}

		for it in dict.meta_terms {
			self.freq_terms.insert(it.expression, it.data);
		}

		for it in dict.meta_kanji {
			self.freq_kanji.insert(it.expression, it.data);
		}

		for it in dict.terms {
			self.import_term(it);
		}

		for it in dict.kanji {
			self.import_kanji(it);
		}
	}

	/// Post-processing after finishing all `import_dict` calls.
	pub fn finish_import(&mut self) {
		for it in self.terms.iter_mut() {
			it.frequency = self.freq_terms.get(&self.strings[it.expression]).cloned();
		}

		for it in self.kanji.iter_mut() {
			it.frequency = self.freq_kanji.get(&it.character.to_string()).cloned();
		}

		self.terms
			.sort_by(|a: &TermRow, b: &TermRow| -> std::cmp::Ordering {
				b.frequency.cmp(&a.frequency)
			});

		self.kanji
			.sort_by(|a: &KanjiRow, b: &KanjiRow| -> std::cmp::Ordering {
				b.frequency.cmp(&a.frequency)
			});
	}

	/// Dumps information about the database to the console.
	pub fn dump_info(&self) {
		let str_bytes = self.strings.iter().map(|x| x.len()).sum();
		println!(
			"- Strings: {}\t~ {:>9}",
			self.strings.len(),
			bytes(str_bytes)
		);
	}

	/// Outputs all data to code files.
	pub fn output(&self) -> io::Result<()> {
		const PRELUDE: &'static str =
			"// This file is autogenerated by `make import`\n// spell-checker: disable\n";

		//
		// Output strings
		//

		println!("... writing data/strings.in");
		let mut strings = BufWriter::new(fs::File::create("data/strings.in")?);
		write!(strings, "{}\n", PRELUDE)?;
		for s in self.strings.iter() {
			write!(strings, "r#\"{}\"#,\n", s)?;
		}
		write!(strings, "\n")?;
		drop(strings);

		//
		// Output tags
		//

		println!("... writing data/tags.in");
		let mut tags = BufWriter::new(fs::File::create("data/tags.in")?);
		write!(tags, "{}\n", PRELUDE)?;
		write!(tags, "// Fields: name, category, order, note\n\n")?;
		for tag in self.tags.iter() {
			write!(
				tags,
				"{{ {}, {}, {}, r#\"{}\"# }},\n",
				tag.name, tag.category, tag.order, tag.notes
			)?;
		}
		write!(tags, "\n")?;
		drop(tags);

		//
		// Output terms
		//

		println!("... writing data/terms.in");
		let mut terms = BufWriter::new(fs::File::create("data/terms.in")?);
		write!(terms, "{}\n", PRELUDE)?;
		write!(terms, "// Fields: expression, reading, score, sequence, frequency, glossary, rules, term_tags, definition_tags\n\n")?;
		for it in self.terms.iter() {
			write!(
				terms,
				"{{ {}, {}, {}, {}, ",
				it.expression, it.reading, it.score, it.sequence
			)?;
			if let Some(freq) = it.frequency {
				write!(terms, "Some({}), ", freq)?;
			} else {
				write!(terms, "None, ")?;
			}
			csv(&mut terms, &it.glossary)?;
			write!(terms, ", ")?;

			csv(&mut terms, &it.rules)?;
			write!(terms, ", ")?;

			csv(&mut terms, &it.term_tags)?;
			write!(terms, ", ")?;

			csv(&mut terms, &it.definition_tags)?;
			write!(terms, " ")?;

			write!(terms, "}},\n")?;
		}
		write!(terms, "\n")?;
		drop(terms);

		//
		// Output kanji
		//

		println!("... writing data/kanji.in");
		let mut kanji = BufWriter::new(fs::File::create("data/kanji.in")?);
		write!(kanji, "{}\n", PRELUDE)?;
		write!(kanji, "// Fields: character, frequency, meanings, onyomi, kunyomi, tags, stats(tag, desc)\n\n")?;
		for it in self.kanji.iter() {
			write!(kanji, "{{ '{}', ", it.character)?;
			if let Some(freq) = it.frequency {
				write!(kanji, "Some({}), ", freq)?;
			} else {
				write!(kanji, "None, ")?;
			}
			csv(&mut kanji, &it.meanings)?;
			write!(kanji, ", ")?;

			csv(&mut kanji, &it.onyomi)?;
			write!(kanji, ", ")?;

			csv(&mut kanji, &it.kunyomi)?;
			write!(kanji, ", ")?;

			csv(&mut kanji, &it.tags)?;
			write!(kanji, ", ")?;

			write!(kanji, "&[")?;
			for (i, (k, v)) in it.stats.iter().enumerate() {
				if i > 0 {
					write!(kanji, ", ")?;
				}
				write!(kanji, "({}, {})", k, v)?;
			}
			write!(kanji, "] ")?;

			write!(kanji, "}},\n")?;
		}
		write!(kanji, "\n")?;
		drop(kanji);

		Ok(())
	}

	fn import_term(&mut self, term: Term) {
		let row = TermRow {
			expression: self.intern(term.expression),
			reading: self.intern(term.reading),
			score: term.score,
			sequence: term.sequence,
			glossary: self.intern_all(term.glossary),
			frequency: None,
			rules: self.get_tags(term.rules),
			term_tags: self.get_tags(term.term_tags),
			definition_tags: self.get_tags(term.definition_tags),
		};
		self.terms.push(row);
	}

	fn import_kanji(&mut self, kanji: Kanji) {
		let row = KanjiRow {
			character: kanji.character,
			meanings: self.intern_all(kanji.meanings),
			onyomi: self.intern_all(kanji.onyomi),
			kunyomi: self.intern_all(kanji.kunyomi),
			frequency: None,
			tags: self.get_tags(kanji.tags),
			stats: kanji
				.stats
				.into_iter()
				.map(|(k, v)| (self.intern(k), self.intern(v)))
				.collect(),
		};
		self.kanji.push(row);
	}

	fn import_tag(&mut self, tag: Tag) {
		let name_id = self.intern(tag.name);
		let category_id = self.intern(tag.category);
		if let Some(&old_tag_id) = self.tag_map.get(&name_id) {
			let old_tag = &mut self.tags[old_tag_id];
			if tag.notes.len() > 0 && tag.notes != old_tag.notes {
				if old_tag.notes.len() > 0 {
					old_tag.notes = format!("{} / {}", old_tag.notes, tag.notes);
				} else {
					old_tag.notes = tag.notes;
				}
			}
			if category_id != 0 && category_id != old_tag.category {
				if old_tag.category != 0 {
					eprintln!(
						"WARNING: overridden category of tag `{}` (was `{}`, with `{}`)",
						&self.strings[name_id],
						&self.strings[old_tag.category],
						&self.strings[category_id]
					)
				}
				old_tag.category = category_id;
			}
		} else {
			let row = TagRow {
				name: name_id,
				category: category_id,
				order: tag.order,
				notes: tag.notes,
			};
			let row_id = self.tags.len();
			self.tags.push(row);
			self.tag_map.insert(name_id, row_id);
		}
	}

	fn get_tags(&mut self, tags: Vec<String>) -> Vec<usize> {
		tags.into_iter().map(|x| self.get_tag(x)).collect()
	}

	fn get_tag(&mut self, name: String) -> usize {
		let name_id = self.intern(name);
		if let Some(&tag_id) = self.tag_map.get(&name_id) {
			tag_id
		} else {
			let row = TagRow {
				name: name_id,
				category: 0,
				order: 0,
				notes: String::new(),
			};
			let row_id = self.tags.len();
			self.tags.push(row);
			self.tag_map.insert(name_id, row_id);
			row_id
		}
	}

	fn intern_all(&mut self, values: Vec<String>) -> Vec<usize> {
		values.into_iter().map(|x| self.intern(x)).collect()
	}

	fn intern(&mut self, value: String) -> usize {
		if self.strings.len() == 0 {
			// Make sure that the empty string is mapped to the zero index
			self.strings.push(String::new());
			self.indexes.insert(String::new(), 0);
		}
		if let Some(index) = self.indexes.get(&value) {
			*index
		} else {
			let next = self.strings.len() as usize;
			self.indexes.insert(value.clone(), next);
			self.strings.push(value);
			next
		}
	}
}

#[derive(Default)]
struct TagRow {
	name: usize,
	category: usize,
	order: i32,
	notes: String,
}

#[derive(Default)]
struct KanjiRow {
	character: char,
	frequency: Option<u32>,
	meanings: Vec<usize>,
	onyomi: Vec<usize>,
	kunyomi: Vec<usize>,
	tags: Vec<usize>,
	stats: HashMap<usize, usize>,
}

#[derive(Default)]
struct TermRow {
	expression: usize,
	reading: usize,
	score: i32,
	sequence: i32,
	frequency: Option<u32>,
	glossary: Vec<usize>,
	rules: Vec<usize>,
	term_tags: Vec<usize>,
	definition_tags: Vec<usize>,
}

fn bytes(value: usize) -> String {
	if value == 1 {
		String::from("1 byte")
	} else if value < 1024 {
		format!("{} bytes", value)
	} else if value < 1024 * 1024 {
		let kb = (value as f64) / 1024.0;
		format!("{:.2} KB", kb)
	} else {
		let mb = (value as f64) / (1024.0 * 1024.0);
		format!("{:.2} MB", mb)
	}
}

fn csv<T: Write>(out: &mut T, values: &Vec<usize>) -> io::Result<()> {
	write!(out, "&[")?;
	for (i, it) in values.iter().enumerate() {
		if i > 0 {
			write!(out, ", ")?;
		}
		write!(out, "{}", it)?;
	}
	write!(out, "]")?;
	Ok(())
}
